---
title: "width_bunnseki"
author: "bian"
date: "2024-12-10"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## R Markdown

This is an R Markdown document. Markdown is a simple formatting syntax for authoring HTML, PDF, and MS Word documents. For more details on using R Markdown see <http://rmarkdown.rstudio.com>.

When you click the **Knit** button a document will be generated that includes both content as well as the output of any embedded R code chunks within the document. You can embed an R code chunk like this:

```{r cars}
summary(cars)
```

## Including Plots

You can also embed plots, for example:

```{r pressure, echo=FALSE}
plot(pressure)
```

Note that the `echo = FALSE` parameter was added to the code chunk to prevent printing of the R code that generated the plot.

```{r}
df <- read.csv("widthbunnseki_clean_psychometric_mean_3sd_all.csv", stringsAsFactors = FALSE)

# 只保留condition为"u1"和"f"的数据
filtered_df <- df[df$condition %in% c("u1", "f"), ]

# 创建一个空的数据框来存储结果
result_df <- data.frame()

# 对每个唯一的No进行处理
unique_nos <- unique(filtered_df$No)

for(participant in unique_nos) {
  # 获取该参与者的数据
  participant_data <- filtered_df[filtered_df$No == participant, ]
  
  # 只有当参与者同时有u1和f的数据时才处理
  if(all(c("u1", "f") %in% participant_data$condition)) {
    width_u1 <- participant_data$Width[participant_data$condition == "u1"]
    width_f <- participant_data$Width[participant_data$condition == "f"]
    
new_row <- data.frame(
  No = participant,
  order = participant_data$order[1],
  gender = participant_data$gender[1],
  AQ = participant_data$AQ[1],
  age = participant_data$age[1],
  width_u1 = width_u1,
  width_f = width_f,
  pi20 = participant_data$PI20[1],
  selfkey = participant_data$selfkey[1],
  s1 = participant_data$social[1],
  s2 = participant_data$attention_switching[1],
  s3 = participant_data$local_attention[1],
  s4 = participant_data$communication[1],
  s5 = participant_data$imagination[1],
  RT = participant_data$RT_mean[1],
  width_change = ifelse(participant_data$order[1] == "fu",
                       ifelse(width_f > width_u1, "down", "up"),
                       ifelse(width_f > width_u1, "up", "down")),
  width_change_data = abs(width_f - width_u1)
)
    
    # 将新行添加到结果数据框中
    result_df <- rbind(result_df, new_row)
  }
}

# 按No排序
result_df <- result_df[order(result_df$No), ]

# 显示结果
print(result_df)
```

```{r}
# 加载必要的包
library(ggplot2)
library(dplyr)
library(car)

df <- result_df

# 3. 对AQ进行t检验
leveneTest(AQ ~ width_change, data = df)
t.test(AQ ~ width_change, data = df)
```
```{r}
# 创建包含所有因变量的矩阵
dv <- cbind(df$s1, df$s2, df$s3, df$s4, df$s5)

# 进行 MANOVA
manova_result <- manova(dv ~ width_change, data = df)
summary(manova_result)
```
```{r}
library(car)
aq_vars <- c("s1", "s2", "s3", "s4", "s5")
# 进行方差齐性检验
for(var in aq_vars) {
  formula <- as.formula(paste(var, "~ width_change"))
  print(paste("Levene's test for", var))
  print(leveneTest(formula, data = df))
}

t.test(s1 ~ width_change, data = df)
t.test(s2 ~ width_change, data = df)
t.test(s3 ~ width_change, data = df)
t.test(s4 ~ width_change, data = df)
t.test(s5 ~ width_change, data = df)
```
```{r}
# 加载必要的包
library(ggplot2)
library(dplyr)

# 创建箱线图
p <- ggplot(df, aes(x = width_change, y = AQ, fill = width_change)) +
  geom_boxplot(alpha = 0.7) +
  geom_jitter(width = 0.2, alpha = 0.4) +  # 添加散点以显示原始数据分布
  stat_summary(fun = mean, geom = "point", shape = 18, size = 3, color = "black") +  # 添加均值点
  scale_fill_manual(values = c("up" = "#66C2A5", "down" = "#FC8D62")) +
  theme_minimal() +
  labs(
    title = "AQ Scores by Width Change Direction",
    subtitle = sprintf("t = %.3f, df = %.3f, p = %.3f", 2.6107, 45.248, 0.01221),
    x = "Width Change Direction",
    y = "AQ Score"
  ) +
  theme(
    plot.title = element_text(hjust = 0.5, face = "bold"),
    plot.subtitle = element_text(hjust = 0.5),
    legend.position = "none",
    axis.title = element_text(face = "bold"),
    panel.grid.major = element_line(color = "grey90"),
    panel.grid.minor = element_line(color = "grey95")
  )

# 添加描述性统计
summary_stats <- df %>%
  group_by(width_change) %>%
  summarise(
    n = n(),
    mean = mean(AQ),
    sd = sd(AQ),
    se = sd/sqrt(n)
  )

# 打印描述性统计
print(summary_stats)

# 显示图形
print(p)
```